<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>NMS Radar Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <style>
    html,body{
      margin:0;
      padding:0;
      height:100%;
      background:#050308;
      overflow:hidden;
      font-family:system-ui,Arial,sans-serif;
    }
    .wrap{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      background:radial-gradient(circle at 50% 0%,#3a1a01 0,#050308 60%);
    }
    canvas{
      max-width:90vmin;
      max-height:90vmin;
      width:90vmin;
      height:90vmin;
      display:block;
    }
  </style>
</head>
<body>
<div class="wrap">
  <canvas id="radar"></canvas>
</div>

<script>
(function() {
  const canvas = document.getElementById('radar');
  const dpr = window.devicePixelRatio || 1;
  let ctx, size, center, radius;

  function resize() {
    const minSide = Math.min(window.innerWidth, window.innerHeight) * 0.8;
    size = minSide;
    canvas.style.width = size + "px";
    canvas.style.height = size + "px";
    canvas.width = size * dpr;
    canvas.height = size * dpr;
    ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
    center = { x: size/2, y: size/2 };
    radius = size * 0.4;
  }
  window.addEventListener('resize', resize);
  resize();

  // --- RADAR STATE ---
  let sweepAngle = 0; // radians
  const sweepSpeed = Math.PI * 0.25; // radians per second
  const sweepWidth = Math.PI / 10;   // width of cone

  const targets = [];
  const maxTargets = 7;

  function randomTargets() {
    targets.length = 0;
    for (let i = 0; i < maxTargets; i++) {
      const r = Math.random() * 0.85 + 0.1; // 0.1..0.95 of radius
      const a = Math.random() * Math.PI * 2;
      targets.push({
        rNorm: r,
        angle: a,
        lastPing: 0
      });
    }
  }
  randomTargets();

  function angleDiff(a,b){
    let d = a-b;
    while (d > Math.PI) d -= Math.PI*2;
    while (d < -Math.PI) d += Math.PI*2;
    return Math.abs(d);
  }

  function draw(timestamp) {
    if (!ctx) return;
    requestAnimationFrame(draw);

    const t = timestamp / 1000; // seconds
    const dt = 1/60;

    sweepAngle += sweepSpeed * dt;
    if (sweepAngle > Math.PI * 2) sweepAngle -= Math.PI * 2;

    // background clear
    ctx.clearRect(0,0,size,size);

    // slight vignette / panel
    ctx.save();
    ctx.translate(center.x, center.y);

    // panel base
    const grdBg = ctx.createRadialGradient(0,0,0,0,0,radius*1.3);
    grdBg.addColorStop(0,"#2a1000");
    grdBg.addColorStop(0.6,"#0f0500");
    grdBg.addColorStop(1,"#000000");
    ctx.fillStyle = grdBg;
    ctx.fillRect(-radius*1.4,-radius*1.1,radius*2.8,radius*2.0);

    // outer glow circle
    ctx.beginPath();
    ctx.arc(0,0,radius*1.02,0,Math.PI*2);
    const gOuter = ctx.createRadialGradient(0,0,radius*0.2,0,0,radius*1.05);
    gOuter.addColorStop(0,"rgba(255,196,120,0.05)");
    gOuter.addColorStop(0.7,"rgba(255,160,40,0.5)");
    gOuter.addColorStop(1,"rgba(0,0,0,0)");
    ctx.fillStyle = gOuter;
    ctx.fill();

    // radar base circle
    ctx.beginPath();
    ctx.arc(0,0,radius,0,Math.PI*2);
    ctx.fillStyle = "#210902";
    ctx.fill();

    // concentric rings
    ctx.lineWidth = 1;
    for(let i=1;i<=7;i++){
      ctx.beginPath();
      ctx.arc(0,0,radius*(i/7),0,Math.PI*2);
      ctx.strokeStyle = "rgba(255,160,40,"+(0.12+0.06*i)+")";
      ctx.stroke();
    }

    // radial ticks
    ctx.save();
    ctx.strokeStyle = "rgba(255,180,80,0.25)";
    ctx.lineWidth = 1;
    for(let i=0;i<8;i++){
      const ang = (Math.PI*2/8)*i;
      ctx.beginPath();
      ctx.moveTo(Math.cos(ang)*radius*0.15, Math.sin(ang)*radius*0.15);
      ctx.lineTo(Math.cos(ang)*radius,      Math.sin(ang)*radius);
      ctx.stroke();
    }
    ctx.restore();

    // dome arc (3D half sphere)
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.lineWidth = 3;
    const domeR = radius*1.03;
    const domeGrad = ctx.createLinearGradient(0,-domeR,0,domeR);
    domeGrad.addColorStop(0,"rgba(255,200,120,0.0)");
    domeGrad.addColorStop(0.5,"rgba(255,180,80,0.5)");
    domeGrad.addColorStop(1,"rgba(255,120,0,0.0)");
    ctx.strokeStyle = domeGrad;
    ctx.beginPath();
    ctx.arc(0,0,domeR,-Math.PI*0.9,Math.PI*0.9);
    ctx.stroke();
    ctx.restore();

    // sweep cone
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    const start = sweepAngle - sweepWidth;
    const end   = sweepAngle;
    const sweepR = radius*1.02;

    const gSweep = ctx.createRadialGradient(0,0,0,0,0,sweepR);
    gSweep.addColorStop(0,"rgba(255,230,180,0.0)");
    gSweep.addColorStop(0.1,"rgba(255,220,150,0.7)");
    gSweep.addColorStop(1,"rgba(255,150,0,0.0)");

    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.arc(0,0,sweepR,start,end,false);
    ctx.closePath();
    ctx.fillStyle = gSweep;
    ctx.fill();
    ctx.restore();

    // center marker
    ctx.beginPath();
    ctx.arc(0,0,4,0,Math.PI*2);
    ctx.fillStyle = "#ffe6b0";
    ctx.fill();

    // targets
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for(const target of targets){
      const r = radius * target.rNorm;
      const a = target.angle;

      const x = Math.cos(a)*r;
      const y = Math.sin(a)*r;

      const diff = angleDiff(a, sweepAngle);
      const isPing = diff < sweepWidth*0.8;

      if (isPing) target.lastPing = t;

      const timeSincePing = t - target.lastPing;
      let pulse = 0;
      if (timeSincePing >= 0 && timeSincePing < 0.5) {
        pulse = 1 - (timeSincePing/0.5);
      }

      // trail line to edge
      ctx.strokeStyle = "rgba(255,180,60,"+(0.25+0.4*pulse)+")";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x,y);
      ctx.lineTo(Math.cos(a)*radius, Math.sin(a)*radius);
      ctx.stroke();

      // target marker
      const baseAlpha = 0.5 + 0.5*pulse;
      ctx.fillStyle = "rgba(255,200,140,"+baseAlpha+")";
      const sz = 6 + pulse*4;
      ctx.beginPath();
      ctx.rect(x-sz/2,y-sz/2,sz,sz);
      ctx.fill();

      // ping halo
      if (pulse>0.01){
        ctx.beginPath();
        ctx.arc(x,y,sz+6,0,Math.PI*2);
        ctx.strokeStyle = "rgba(255,200,120,"+(0.4*pulse)+")";
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }
    }
    ctx.restore();

    ctx.restore();
  }

  requestAnimationFrame(draw);
})();
</script>

</body>
</html>
